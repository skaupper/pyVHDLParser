# ==================================================================================================================== #
#            __     ___   _ ____  _     ____                                                                           #
#  _ __  _   \ \   / / | | |  _ \| |   |  _ \ __ _ _ __ ___  ___ _ __                                                  #
# | '_ \| | | \ \ / /| |_| | | | | |   | |_) / _` | '__/ __|/ _ \ '__|                                                 #
# | |_) | |_| |\ V / |  _  | |_| | |___|  __/ (_| | |  \__ \  __/ |                                                    #
# | .__/ \__, | \_/  |_| |_|____/|_____|_|   \__,_|_|  |___/\___|_|                                                    #
# |_|    |___/                                                                                                         #
# ==================================================================================================================== #
# Authors:                                                                                                             #
#   Patrick Lehmann                                                                                                    #
#                                                                                                                      #
# License:                                                                                                             #
# ==================================================================================================================== #
# Copyright 2017-2023 Patrick Lehmann - Boetzingen, Germany                                                            #
# Copyright 2016-2017 Patrick Lehmann - Dresden, Germany                                                               #
#                                                                                                                      #
# Licensed under the Apache License, Version 2.0 (the "License");                                                      #
# you may not use this file except in compliance with the License.                                                     #
# You may obtain a copy of the License at                                                                              #
#                                                                                                                      #
#   http://www.apache.org/licenses/LICENSE-2.0                                                                         #
#                                                                                                                      #
# Unless required by applicable law or agreed to in writing, software                                                  #
# distributed under the License is distributed on an "AS IS" BASIS,                                                    #
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.                                             #
# See the License for the specific language governing permissions and                                                  #
# limitations under the License.                                                                                       #
# ==================================================================================================================== #
#
from enum                     import IntEnum
from typing                   import Iterator, List
from dataclasses              import dataclass

from pyTooling.Decorators     import export

from pyVHDLParser             import SourceCodePosition
from pyVHDLParser.Base        import ParserException
from pyVHDLParser.Token       import StartOfDocumentToken, EndOfDocumentToken, IndentationToken, FusedCharacterToken, Token
from pyVHDLParser.Token       import CharacterLiteralToken, StringLiteralToken, ExtendedIdentifier, DirectiveToken, IntegerLiteralToken, RealLiteralToken
from pyVHDLParser.Token       import CharacterToken, WhitespaceToken, WordToken, SingleLineCommentToken, MultiLineCommentToken, LinebreakToken


@export
class TokenizerException(ParserException):
	"""A :exc:`~pyVHDLParser.Base.ParserException` generated by the :class:`~pyVHDLParser.Token.Parser.Tokenizer`."""

	def __init__(self, message: str, position: SourceCodePosition):
		super().__init__(message)
		self.Position = position

	def __str__(self) -> str:
		return f"{self.Position!s}: {self._message}"


class TokenKind(IntEnum):
	"""Enumeration of all Tokenizer states."""

	SpaceChars =                      0   #: Last char was a space
	IntegerChars =                    1   #: Last char was a digit
	RealChars =                       2   #: Last char was a digit
	AlphaChars =                      3   #: Last char was a letter
	DelimiterChars =                  4   #: Last char was a delimiter character
	PossibleSingleLineCommentStart =  5   #: Last char was a dash
	PossibleLinebreak =               6   #: Last char was a ``\r``
	PossibleRealLiteral =             7   #: Last char was a ``.``
	PossibleCharacterLiteral =        8   #: Last char was a ``'``
	PossibleStringLiteralStart =      9   #: Last char was a ``"``
	PossibleStringLiteralEnd =        10  #: Last char was a ``"`` while being in state ``PossibleStringLiteralStart``
	PossibleExtendedIdentifierStart = 11  #: Last char was a ``\``
	SingleLineComment =               12  #: Found ``--`` before
	MultiLineComment =                13  #: Found ``/*`` before
	Linebreak =                       14  #: Last char was a ``\n``
	Directive =                       15  #: Last char was a `` ` ``
	FuseableCharacter =               16  #: Last char was a character that could be fused
	OtherChars =                      17  #: Anything else


@dataclass
class TokenizerState:
	PreviousToken : Token
	TokenKind     : TokenKind
	Start         : SourceCodePosition
	Buffer        : str
	Absolute      : int
	Column        : int
	Row           : int


@export
class Tokenizer:

	__NUMBER_CHARACTERS__ =     "0123456789"
	__ALPHA_CHARACTERS__ =      "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	__WHITESPACE_CHARACTERS__ = " \t"
	__FUSEABLE_CHARS__ =        "=<:/*>?"


	@classmethod
	def ChangeState(cls, char: str, state: TokenizerState) -> List[Token]:
		# Wrap the results in a list, so the caller can use `yield from`
		resultTokens: List[Token] = []

		state.Start =   SourceCodePosition(state.Row, state.Column, state.Absolute)
		state.Buffer =  char
		if char in cls.__WHITESPACE_CHARACTERS__: state.TokenKind = TokenKind.SpaceChars
		elif char in cls.__NUMBER_CHARACTERS__:   state.TokenKind = TokenKind.IntegerChars
		elif char in cls.__ALPHA_CHARACTERS__:    state.TokenKind = TokenKind.AlphaChars
		elif char == "'":                         state.TokenKind = TokenKind.PossibleCharacterLiteral
		elif char == "\"":                        state.TokenKind = TokenKind.PossibleStringLiteralStart
		elif char == "-":                         state.TokenKind = TokenKind.PossibleSingleLineCommentStart
		elif char == "\r":                        state.TokenKind = TokenKind.PossibleLinebreak
		elif char == "\n":
			state.PreviousToken = LinebreakToken(state.PreviousToken, char, state.Start, state.Start)
			resultTokens.append(state.PreviousToken)
			state.TokenKind = TokenKind.OtherChars
		elif char in cls.__FUSEABLE_CHARS__:
			if state.TokenKind != TokenKind.FuseableCharacter:
				state.Buffer =      char
				state.TokenKind =   TokenKind.FuseableCharacter
		elif char == ".":                         state.TokenKind = TokenKind.PossibleRealLiteral
		elif char == "\\":                        state.TokenKind = TokenKind.PossibleExtendedIdentifierStart
		elif (char == "`") and isinstance(state.PreviousToken, (WhitespaceToken, LinebreakToken)):
			state.TokenKind = TokenKind.Directive
		else:
			state.PreviousToken = CharacterToken(state.PreviousToken, char, state.Start)
			resultTokens.append(state.PreviousToken)
			state.TokenKind =     TokenKind.OtherChars

		return resultTokens


	@classmethod
	def GetVHDLTokenizer(cls, iterable: Iterator[str]):
		state = TokenizerState(
			PreviousToken = StartOfDocumentToken(),
			TokenKind =     TokenKind.OtherChars,
			Start =         SourceCodePosition(1, 1, 1),
			Buffer =        "",
			Absolute =      0,
			Column =        0,
			Row =           1
		)

		yield state.PreviousToken

		for char in iterable:
			state.Absolute +=   1
			state.Column +=     1

			# State: SpaceChars
			if state.TokenKind is TokenKind.SpaceChars:
				if char in cls.__WHITESPACE_CHARACTERS__:
					state.Buffer += char
				else:
					end = SourceCodePosition(state.Row, state.Column - 1, state.Absolute - 1)
					if isinstance(state.PreviousToken, (LinebreakToken, SingleLineCommentToken, StartOfDocumentToken)):
						state.PreviousToken = IndentationToken(state.PreviousToken, state.Buffer, state.Start, end)
					else:
						state.PreviousToken = WhitespaceToken(state.PreviousToken, state.Buffer, state.Start, end)
					yield state.PreviousToken

					yield from cls.ChangeState(char, state)

			# State: IntegerChars
			elif state.TokenKind is TokenKind.IntegerChars:
				if (char in cls.__NUMBER_CHARACTERS__) or (char == "_"):
					state.Buffer += char
				elif char == ".":
					state.Buffer += char
					state.TokenKind = TokenKind.RealChars
				else:
					state.PreviousToken = IntegerLiteralToken(state.PreviousToken, state.Buffer, state.Start, SourceCodePosition(state.Row, state.Column, state.Absolute))
					yield state.PreviousToken

					yield from cls.ChangeState(char, state)

			# State: RealChars
			elif state.TokenKind is TokenKind.RealChars:
				if (char in cls.__NUMBER_CHARACTERS__) or (char == "_"):
					state.Buffer += char
				else:
					state.PreviousToken = RealLiteralToken(state.PreviousToken, state.Buffer, state.Start, SourceCodePosition(state.Row, state.Column, state.Absolute))
					yield state.PreviousToken

					yield from cls.ChangeState(char, state)

			# State: AlphaChars
			elif state.TokenKind is TokenKind.AlphaChars:
				if (char in cls.__ALPHA_CHARACTERS__) or (char == "_"):
					state.Buffer += char
				else:
					state.PreviousToken = WordToken(state.PreviousToken, state.Buffer, state.Start, SourceCodePosition(state.Row, state.Column, state.Absolute))
					yield state.PreviousToken

					yield from cls.ChangeState(char, state)

			# State: PossibleSingleLineCommentStart
			elif state.TokenKind is TokenKind.PossibleSingleLineCommentStart:
				if char == "-":
					state.Buffer =    "--"
					state.TokenKind = TokenKind.SingleLineComment
				else:
					state.PreviousToken = CharacterToken(state.PreviousToken, "-", state.Start)
					yield state.PreviousToken

					yield from cls.ChangeState(char, state)

			# State: PossibleLinebreak
			elif state.TokenKind is TokenKind.PossibleLinebreak:
				end = SourceCodePosition(state.Row, state.Column, state.Absolute)
				if char == "\n":
					state.TokenKind = TokenKind.OtherChars
					if state.Buffer[:2] == "--":
						state.Buffer += char
						state.PreviousToken = SingleLineCommentToken(state.PreviousToken, state.Buffer, state.Start, end)
					else:
						state.PreviousToken = LinebreakToken(state.PreviousToken, "\r\n", state.Start, end)
					state.Buffer = "\r\n"
					yield state.PreviousToken
				else:
					state.PreviousToken = LinebreakToken(state.PreviousToken, "\r", state.Start, end)
					yield state.PreviousToken

					yield from cls.ChangeState(char, state)

			# State: PossibleRealLiteral
			elif state.TokenKind is TokenKind.PossibleRealLiteral:
				if char in cls.__NUMBER_CHARACTERS__:
					state.Buffer +=   char
					state.TokenKind = TokenKind.RealChars
				else:
					state.PreviousToken = CharacterToken(state.PreviousToken, ".", state.Start)
					yield state.PreviousToken

					yield from cls.ChangeState(char, state)

			# State: PossibleCharacterLiteral
			elif state.TokenKind is TokenKind.PossibleCharacterLiteral:
				state.Buffer += char
				if len(state.Buffer) == 2:
					if state.Buffer[1] == "(" and isinstance(state.PreviousToken, WordToken):
						# An input of the form `<word>'(` always must be a qualified expression
						# in order to be valid VHDL. There is not case where `'('` would be a valid character literal
						# if preceeded by a word token
						state.PreviousToken =   CharacterToken(state.PreviousToken, "'", state.Start)
						yield state.PreviousToken
						state.PreviousToken =   CharacterToken(state.PreviousToken, "(", SourceCodePosition(state.Row, state.Column, state.Absolute))
						yield state.PreviousToken
						state.TokenKind =       TokenKind.OtherChars
					else:
						continue
				elif (len(state.Buffer) == 3) and (state.Buffer[2] == "'"):
					# Whatever is enclosed in single quotes, is the content of a character literal
					state.PreviousToken =   CharacterLiteralToken(state.PreviousToken, state.Buffer, state.Start, SourceCodePosition(state.Row, state.Column, state.Absolute))
					yield state.PreviousToken
					state.TokenKind = TokenKind.OtherChars
				else:
					# If the third entry of the state.Buffer is not a closing single quote, the single quote must belong to an attribute
					state.PreviousToken =   CharacterToken(state.PreviousToken, "'", state.Start)
					yield state.PreviousToken

					state.Start.Column +=   1
					state.Start.Absolute += 1
					state.Buffer =          state.Buffer[1:]
					if (state.Buffer[0] in cls.__ALPHA_CHARACTERS__) and (state.Buffer[1] in cls.__ALPHA_CHARACTERS__):
						state.TokenKind =     TokenKind.AlphaChars
					elif (state.Buffer[0] in cls.__WHITESPACE_CHARACTERS__) and (state.Buffer[1] in cls.__WHITESPACE_CHARACTERS__):
						state.TokenKind =     TokenKind.SpaceChars
					else:
						raise TokenizerException("Ambiguous syntax detected. state.Buffer: '{buffer}'".format(buffer=state.Buffer), state.Start)

			# State: PossibleStringLiteralStart
			elif state.TokenKind is TokenKind.PossibleStringLiteralStart:
				state.Buffer += char
				if char == "\"":
					state.TokenKind = TokenKind.PossibleStringLiteralEnd

			# State: PossibleStringLiteralEnd
			elif state.TokenKind is TokenKind.PossibleStringLiteralEnd:
				if char == "\"":
					state.Buffer += char
					state.TokenKind = TokenKind.PossibleStringLiteralStart
				else:
					state.PreviousToken = StringLiteralToken(state.PreviousToken, state.Buffer, state.Start, SourceCodePosition(state.Row, state.Column-1, state.Absolute-1))
					yield state.PreviousToken

					yield from cls.ChangeState(char, state)

			# State: PossibleExtendedIdentifierStart
			elif state.TokenKind is TokenKind.PossibleExtendedIdentifierStart:
				state.Buffer += char
				if char == "\\":
					state.PreviousToken = ExtendedIdentifier(state.PreviousToken, state.Buffer, state.Start, SourceCodePosition(state.Row, state.Column, state.Absolute))
					yield state.PreviousToken
					state.TokenKind =     TokenKind.OtherChars

			# State: Directive
			elif state.TokenKind is TokenKind.Directive:
				state.Buffer += char
				if char == "\r":
					state.TokenKind =     TokenKind.PossibleLinebreak
				elif char == "\n":
					state.PreviousToken = DirectiveToken(state.PreviousToken, state.Buffer, state.Start, SourceCodePosition(state.Row, state.Column, state.Absolute))
					yield state.PreviousToken
					state.TokenKind =     TokenKind.OtherChars

			# State: SingleLineComment
			elif state.TokenKind is TokenKind.SingleLineComment:
				state.Buffer += char
				if char == "\r":
					state.TokenKind =     TokenKind.PossibleLinebreak
				elif char == "\n":
					state.PreviousToken = SingleLineCommentToken(state.PreviousToken, state.Buffer, state.Start, SourceCodePosition(state.Row, state.Column, state.Absolute))
					yield state.PreviousToken
					state.TokenKind =     TokenKind.OtherChars

			# State: MultiLineComment
			elif state.TokenKind is TokenKind.MultiLineComment:
				state.Buffer += char
				if state.Buffer[-2:] == "*/":
					state.PreviousToken = MultiLineCommentToken(state.PreviousToken, state.Buffer, state.Start, SourceCodePosition(state.Row, state.Column, state.Absolute))
					yield state.PreviousToken
					state.TokenKind =     TokenKind.OtherChars

			# State: FuseableCharacter
			elif state.TokenKind is TokenKind.FuseableCharacter:
				fused = state.Buffer + char
				if fused in ("=>", "**", ":=", "/=", "<=", ">=", "<>", "<<", ">>", "??", "?=", "?<", "?>", "?/=", "?<=", "?>="):
					state.PreviousToken = FusedCharacterToken(state.PreviousToken, fused, state.Start, SourceCodePosition(state.Row, state.Column, state.Absolute))
					yield state.PreviousToken
					state.TokenKind = TokenKind.OtherChars
				elif fused in ("?/", "?<", "?>"):
					state.Buffer =    fused
				elif fused == "/*":
					state.Buffer =    fused
					state.TokenKind = TokenKind.MultiLineComment
				else:
					state.PreviousToken = CharacterToken(state.PreviousToken, state.Buffer[0], state.Start)
					yield state.PreviousToken
					if len(state.Buffer) == 2:
						state.PreviousToken = CharacterToken(state.PreviousToken, state.Buffer[1], state.Start)
						yield state.PreviousToken

					yield from cls.ChangeState(char, state)

			# State: OtherChars
			elif state.TokenKind is TokenKind.OtherChars:
				yield from cls.ChangeState(char, state)

			# State: unknown
			else:
				raise TokenizerException("Unknown state.", SourceCodePosition(state.Row, state.Column, state.Absolute))

			if char == "\n":
				state.Column =  0
				state.Row +=    1
		# end for

		if state.TokenKind is TokenKind.MultiLineComment:
			raise TokenizerException("End of document before end of multi line comment.", SourceCodePosition(state.Row, state.Column, state.Absolute))

		# close open token when input stream is empty
		if state.TokenKind is TokenKind.AlphaChars:
			state.PreviousToken = WordToken(state.PreviousToken, state.Buffer, state.Start, SourceCodePosition(state.Row, state.Column, state.Absolute))
			yield state.PreviousToken
		elif state.TokenKind is TokenKind.IntegerChars:
			state.PreviousToken = IntegerLiteralToken(state.PreviousToken, state.Buffer, state.Start, SourceCodePosition(state.Row, state.Column, state.Absolute))
			yield state.PreviousToken
		elif state.TokenKind is TokenKind.RealChars:
			state.PreviousToken = RealLiteralToken(state.PreviousToken, state.Buffer, state.Start, SourceCodePosition(state.Row, state.Column, state.Absolute))
			yield state.PreviousToken
		elif state.TokenKind is TokenKind.SpaceChars:
			end = SourceCodePosition(state.Row, state.Column - 1, state.Absolute - 1)
			if isinstance(state.PreviousToken, (LinebreakToken, SingleLineCommentToken, StartOfDocumentToken)):
				state.PreviousToken = IndentationToken(state.PreviousToken, state.Buffer, state.Start, end)
			else:
				state.PreviousToken = WhitespaceToken(state.PreviousToken, state.Buffer, state.Start, end)
			yield state.PreviousToken
		elif state.TokenKind is TokenKind.SingleLineComment:
			state.PreviousToken = SingleLineCommentToken(state.PreviousToken, state.Buffer, state.Start, SourceCodePosition(state.Row, state.Column, state.Absolute))
			yield state.PreviousToken
		elif state.TokenKind in (TokenKind.OtherChars, TokenKind.DelimiterChars):
			pass
		else:
			raise TokenizerException("End of document before ...", SourceCodePosition(state.Row, state.Column, state.Absolute))

		# End of document
		yield EndOfDocumentToken(state.PreviousToken, SourceCodePosition(state.Row, state.Column, state.Absolute))
